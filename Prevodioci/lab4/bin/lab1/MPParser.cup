package lab1;

import java_cup.runtime.*;
import java.io.*;
import SymbolTable.*;

parser code {:
   public SymbolTable symbolTable = new SymbolTable();
   public int errNo = 0;
   
   public Type currentCaseType = null;
   public Type lastType = null;
   
   public boolean canConvert(Type from, Type to) {
      if (from.tkind == to.tkind) return true;
      if (to.tkind == Type.INTEGER && from.tkind == Type.CHARACTER) return true;
      if (to.tkind == Type.FLOAT && (from.tkind == Type.INTEGER || from.tkind == Type.CHARACTER)) return true;
      return false;
   }

   public Type getHigherType(Type t1, Type t2) {
      if (t1.tkind == Type.FLOAT || t2.tkind == Type.FLOAT) return symbolTable.getType("float");
      if (t1.tkind == Type.INTEGER || t2.tkind == Type.INTEGER) return symbolTable.getType("integer");
      return symbolTable.getType("char");
   }

   public void report_semantic_error(String message, int line) {
      System.out.println("SEMANTICKA GRESKA u liniji " + line + ": " + message);
      errNo++;
   }

   public static void main( String[] args ) {
      try {
         FileReader file = new FileReader( args[0] );
         MPLexer scanner = new MPLexer( file );
         MPParser parser = new MPParser( scanner );
         parser.parse();
         if (parser.errNo == 0)
            System.out.println("Analiza zavrsena. Kod je semanticki ispravan.");
         else
            System.out.println("Analiza zavrsena. Ukupan broj gresaka: " + parser.errNo);
      } catch( Exception e ) {
         e.printStackTrace();
      }
   }
:};

terminal String ID, CONST;
terminal MAIN, INT, CHAR, FLOAT, CASE, WHEN;
terminal PLUS, MINUS, ASSIGN;
terminal LPAREN, RPAREN, LBRACE, RBRACE, SEMICOLON, COMMA, COLON;

non terminal Program, Block, Declarations, VarDecl;
non terminal StatementList, Statement, CaseStatement, WhenStatementList, WhenStatement;
non terminal Type Type, Expression, Term;
non terminal String NameList;
non terminal Integer AddOperator;

start with Program;

Program ::= MAIN LPAREN RPAREN Block ;

Block ::= LBRACE Declarations StatementList RBRACE ;

Declarations ::= Declarations VarDecl 
               | /* epsilon */ ;

VarDecl ::= Type NameList SEMICOLON ;

NameList ::= ID:name
    {:
        if (!parser.symbolTable.addVar(name, parser.lastType))
            parser.report_semantic_error("Dupla definicija: Promenljiva '" + name + "' vec postoji.", nameleft + 1);
    :}
    | NameList COMMA ID:name
    {:
        if (!parser.symbolTable.addVar(name, parser.lastType))
            parser.report_semantic_error("Dupla definicija: Promenljiva '" + name + "' vec postoji.", nameleft + 1);
    :};

Type ::= INT   {: RESULT = parser.symbolTable.getType("integer"); parser.lastType = RESULT; :}
       | CHAR  {: RESULT = parser.symbolTable.getType("char");    parser.lastType = RESULT; :}
       | FLOAT {: RESULT = parser.symbolTable.getType("float");   parser.lastType = RESULT; :};

StatementList ::= StatementList Statement 
                | Statement ;

Statement ::= CaseStatement
            | ID:name ASSIGN Expression:e SEMICOLON
    {:
        Variable v = parser.symbolTable.getVar(name);
        if (v == null) {
            parser.report_semantic_error("Promenljiva '" + name + "' nije deklarisana.", nameleft + 1);
        } else {
            if (!parser.canConvert(e, v.type)) {
                parser.report_semantic_error("Nekompatibilni tipovi kod dodele (" + e.name + " u " + v.type.name + ").", nameleft + 1);
            }
            v.last_def = nameleft + 1;
        }
    :}
            | Block ;

CaseStatement ::= CASE:c LPAREN Expression:e RPAREN 
    {:
        if (e.tkind != Type.CHARACTER && e.tkind != Type.INTEGER)
            parser.report_semantic_error("Izraz u CASE mora biti int ili char.", cleft + 1);
        parser.currentCaseType = e;
    :}
    LBRACE WhenStatementList RBRACE ;

WhenStatementList ::= WhenStatementList WhenStatement 
                    | WhenStatement ;

WhenStatement ::= WHEN:w CONST:c COLON Statement
    {:
        Type constType;
        if (c.startsWith("'")) constType = parser.symbolTable.getType("char");
        else if (c.contains(".") || c.contains("e")) constType = parser.symbolTable.getType("float");
        else constType = parser.symbolTable.getType("integer");

        if (parser.currentCaseType != null && constType.tkind != parser.currentCaseType.tkind) {
            parser.report_semantic_error("Konstanta u WHEN (" + constType.name + ") ne odgovara CASE izrazu (" + parser.currentCaseType.name + ").", wleft + 1);
        }
    :};

Expression ::= Expression:e1 AddOperator Term:t
    {:
        if (e1.tkind == Type.UNKNOWN || t.tkind == Type.UNKNOWN) {
            RESULT = parser.symbolTable.getType("unknown");
        } else if (e1.tkind > 3 || t.tkind > 3) {
            parser.report_semantic_error("Aritmeticki operatori se mogu primeniti samo nad numerickim tipovima.", e1left + 1);
            RESULT = parser.symbolTable.getType("unknown");
        } else {
            RESULT = parser.getHigherType(e1, t);
        }
    :}
    | Term:t {: RESULT = t; :};

Term ::= ID:name
    {:
        Variable v = parser.symbolTable.getVar(name);
        if (v == null) {
            parser.report_semantic_error("Promenljiva '" + name + "' nije deklarisana.", nameleft + 1);
            RESULT = parser.symbolTable.getType("unknown");
        } else {
            if (v.last_def == -1)
                parser.report_semantic_error("Promenljiva '" + name + "' se koristi pre inicijalizacije.", nameleft + 1);
            RESULT = v.type;
        }
    :}
    | CONST:c 
    {: 
        if (c.startsWith("'")) RESULT = parser.symbolTable.getType("char");
        else if (c.contains(".") || c.contains("e")) RESULT = parser.symbolTable.getType("float");
        else RESULT = parser.symbolTable.getType("integer");
    :}
    | LPAREN Expression:e RPAREN {: RESULT = e; :};

AddOperator ::= PLUS | MINUS ;